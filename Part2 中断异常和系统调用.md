# 01.BIOS

## 1.1功能

### 1.1.2基本的输入输出（中断调用的方式）

INT 10h 字符显示

INT 13h 磁盘扇区读写

INT 15h 检测内存大小

INT 16h 键盘输入

且只能在x86的实模式下访问

### 1.1.3系统设置信息

### 1.1.4开机自检程序

### 1.1.5系统自启动程序

# 02.系统启动流程 
![image](https://github.com/Reichitose/OS/blob/main/image_storage/sys_work.png)
## 2.1.CPU初始化

### 2.1.1CPU加电稳定后从0XFFFF0读第一条指令

CS:IP = 0xf00:fff0

第一条指令是跳转指令

### 2.1.2CPU初始状态为16位实模式

CS:IP是16位寄存器

指令指针PC = 16*CS + IP

最大地址空间是1MB

## 2.2.BIOS初始化过程

### 2.2.1硬件自检POST

### 2.2.2检测系统中内存和显卡等关键部件的存在和工作状态

### 2.2.3查找并执行显卡等接口卡的BIOS，进行设备初始化

### 2.2.4执行系统BIOS，进行系统检测

检测和配置系统中安装的即插即用设备

### 2.2.5更新CMOS中的扩展系统配置数据ESCD

### 2.2.6按指定启动顺序从软盘硬盘和光驱启动

## 2.3.主引导记录MBR格式

### 2.3.1启动代码（446字节）

检查分区表的正确性

加载并跳转到磁盘上的引导程序

### 2.3.2硬盘分区表（64字节）

描述分区状态和位置

每个分区描述信息占16字节

### 2.3.3结束标志字（2字节）55AA

主引导记录合法的有效标志

## 2.4.分区引导扇区格式

### 2.4.1跳转指令JMP

跳转到启动代码 与平台相关

### 2.4.2文件卷头结构

文件系统描述信息

### 2.4.3启动代码

跳转到加载程序 可以改动，标识

### 2.4.4结束标志

55AA

## 2.5.加载程序 BootLoader

![image](https://github.com/Reichitose/OS/blob/main/image_storage/BootLoader.png)

加载程序中配置信息由于系统的差异会存在区别，而其中的加载参数包括是否以安全模式启动，是否以调试模式启动等等

## 2.6.系统启动规范

### 2.6.1BIOS

固化在计算机主板的程序

包括系统设置，自检程序和系统自启动程序

BIOS-MBR,BIOS-GPT,PXE

> 在发展之初,bios只需要读取磁盘上的唯一分区进行加载引导记录，在多分区磁盘出现后，有了主引导记录可以选择几个分区中的活动分区（但主引导记录只能使用4个分区，当分区大于四个时就存在问题），所以有了GPT全局唯一表示分区表，使得不用受四个分区的限制.
>
> **预启动执行环境**（Preboot eXecution Environment，PXE）也被称为预执行环境，提供了一种使用网络接口Network Interface）启动计算机的机制。这种机制让计算机的启动可以不依赖本地数据存储设备或本地已安装的操作系统。

### 2.6.2UEFI 统一可扩展固件接口

接口标准

在所有平台上一致的操作系统启动服务



# 03.中断异常和系统调用

## 3.1背景

### 3.1.1为什么需要中断异常和系统调用

在计算机运行中，内核是被信任的第三方

只有内核可以执行特权指令

方便应用程序

### 3.1.2中断和异常希望解决的问题

当外设连接计算机时会出现什么现象

当应用程序处理意想不到的行为时会出现什么现象

### 3.1.3系统调用需要解决的问题

用户应用程序时如何得到系统服务。使用户程序使用内核提供的服务又不至于用户的行为对我内核的安全产生影响

系统调用和功能调用的不同之处

## 3.2内核的进入与退出

![image](https://github.com/Reichitose/OS/blob/main/image_storage/system%20call%20exception%20and%20hardware%20interrupt.png)

操作系统内核和外界打交道主要依靠中断异常和系统调用这三个途径

### 3.2.1系统调用（system call）

应用程序**主动**向操作系统发出的服务请求

### 3.2.2异常（exception）

非法指令或者其他原因导致当前指令**执行失败后**的处理请求

### 3.2.3中断（hardware interrupt）

来自**硬件设备**的处理请求

### 3.2.4比较

#### 3.2.4.1源头

中断：外设

异常：应用系统意向不到的操作（代码出错）

系统调用：应用程序请求操作提供服务

#### 3.2.4.2响应方式

中断：异步   不会被感知到，只是应用程序暂停执行处理完中断所需服务后继续程序的执行

异常：同步  和当前指令有关，必须处理完这条异常指令所导致的问题才会继续

系统调用：异步或同步 发出请求后开始等待直到内核给出结果，也可能是发出请求后内核会干别的事情，等到其他条件准备完成后再返回

#### 3.2.4.3处理机制

中断：会持续进行，对用户应用程序时透明的

异常：杀死或重新执行引起异常的指令

系统调用：等待和持续

## 3.3中断处理机制（此处中断是中断异常和系统调用的统称）

### 3.3.1硬件处理

在cpu初始化时设置中断**使能**标志，即在允许外界对cpu进行中断请求之前，cpu不会对外界的任何中断请求发出响应。只有cpu准备工作结束后。外界中断请求才会被执行。

cpu会记录下中断产生，依据中断向量调用相应的中断服务例程（找到相应的中断源，并由中断向量表进入驱动程序中的中断服务例程）

异常同理进入异常服务例程，系统调用中，由于系统调用的量很大，使用系统调用占用一个系统调用编号，不同的系统调用功能使用系统调用表表示，根据不同的功能进行实现）

### 3.3.2软件

现场保存（编译器）上下文信息

中断服务处理（服务例程）

清除中断标记（服务例程）

现场恢复（编译器）

### 3.3.3中断嵌套

#### 硬件中断服务例程可以被打断

中断源不同 会通过优先级高低进行交替处理

硬件中断服务例程中需要临时禁止中断请求

中断请求会保持到CPU做出响应



#### 异常服务例程可以被打断

异常服务例程执行中可能出现硬件中断（例如虚拟存储中存储单元不存在需要使用磁盘I/O，可能会出现磁盘设备中断）

#### 异常服务例程可嵌套

异常服务例程中可能出现缺页

## 3.4系统调用

### 3.4.1概念

操作系统服务的编程接口

通常由高级语言编写（C，CPP）

程序访问通常是通过高层次的API接口而不是直接进行系统调用

常见的API有Win32 API用于Windows，POSIX API用于UNIX LINUX Mac OS，Java API用于JVM



### 3.4.2实现

#### 每一个系统调用对应一个系统调用编号

系统调用接口根据系统调用编号来维护表的索引

#### 系统调用接口调用内核态中的系统调用功能实现，并返回系统调用的状态和结果

#### 用户不需要知道系统调用的实现

需要设置调用参数和获取返回结果

操作系统接口的细节大部分隐藏在应用编程接口后（通过运行程序支持的库来管理）

### 3.4.3系统调用和函数调用的不同

系统调用使用INT和IRET指令（系统调用时，堆栈切换和特权级的转换）

函数调用使用CALL和RET(常规调用时没有堆栈切换)

> 类比成银行取钱问题，你（用户应用程序）可以告诉营业员（系统调用接口）要取多少钱，而营业员进入保险库（即内核）并提出你所要的钱并在账本上进行记录（即堆栈），而你是不能修改银行的账本或直接进入保险库提取你所需的钱的（特权级）



### 3.4.4中断异常和系统调用的开销

**系统调用的开销超出函数调用**

主要原因：引导机制，建立内核堆栈，验证参数，内核态映射到用户态的地址空间，内核态独立地址空间





