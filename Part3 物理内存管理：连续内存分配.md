# 1.计算机体系结构和内存层次

## 计算机体系结构

### cpu

寄存器  高速缓存（保证大量读写和复用）

### 内存

最小访问单位是8bit 32位总线一次读写4字节 



### I/O设备



## 内存层次

访问层次：高速缓存不命中时访问内存，内存缺页时访问外存，速度逐级下降，最快时与cpu主频一致

## 操作系统的内存管理方式

内存以字节为单位访问

外存磁盘的访问有扇区编号，一个扇区是512字节最小单位

MMU（存储管理单元）将逻辑（虚拟）的地址空间转化为真实的物理地址空间

操作系统在内存中，进程在外存和内存中

### 抽象

逻辑地址空间

### 保护

独立地址空间

### 共享

访问相同内存

### 虚拟化

拥有更大的地址空间

### 操作系统中采用的内存管理方式

#### 重定向（relocation）利用段地址加偏移

#### 分段（segmentation）程序逻辑结构分为代码，数据，堆栈三个部分相对独立

#### 分页（paging）将内存分为更小的段称为页，页内连续

#### 虚拟存储（virtual memory）采用逻辑的地址空间，目前多数系统（Linux）采用按需页式虚拟存储

## 存储管理的实现高度依赖于硬件结构

# 2.地址空间和地址生成

## 地址空间的定义

### 物理地址空间

由硬件支持，起始地址0，直到MAXsys

### 逻辑地址空间

在cpu运行的进程看到的地址，起始地址0，直到MAXprog，这段区域包含在物理地址空间里

## 地址生成

### 逻辑地址的生成

![image](https://github.com/Reichitose/OS/blob/main/image_storage/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%9A%84%E7%94%9F%E6%88%90.png)

源代码的语句被编译为cpu可以理解的汇编码，对汇编码再进行一次汇编变为机器指令，进行链接把多个模块和函数库排列成线性的函数库和指令，进行程序加载（重定位）平移到内存空间中某个位置

###  地址生成的时机和限制

#### 编译时（例如：非智能手机）

假设起始地址已知，如果起始地址改变，必须重新编译

#### 加载时

如果编译时其实位置未知，编译器需生成可重定位的代码（relocatable code），加载时生成绝对地址

#### 执行时（使用虚拟存储的系统里，最优）

执行时才可以确定需要访问的位置，执行时代码可移动，需地址转换（映射）硬件支持

### 生成过程

#### CPU：

ALU：需要逻辑地址的内存内容

MMU：依据页表将逻辑地址转换成物理地址

CPU控制逻辑：给总线发送物理地址请求和控制信号

#### 内存：

识别总线上的内容，发送物理地址的内容给CPU，或者接收CPU的数据到物理地址上，对应读和写

#### 操作系统：

通过逻辑地址LA和物理地址PA的映射，转换的表可以由操作系统控制

## 地址检查

![image](https://github.com/Reichitose/OS/blob/main/image_storage/%E5%9C%B0%E5%9D%80%E6%A3%80%E6%9F%A5.png)



请求由段长度寄存器进行检查，如果要访问的偏移量大于最大段长度，则判定为非法，如果在范围之内，则加上段基址转换为物理地址进行访问

操作系统可以通过软件方法设置base和limit逻辑地址空间



# 3.连续内存分配

连续内存分配是给进程分配一块不小于指定大小的连续的物理存储区域

## 内存碎片

空闲内存不能被利用

### 外部碎片

分配单元之间的未被使用内存

>本质是过小的空闲块而不足以满足进程申请的区域

### 内部碎片

分配单元内的未被使用内存

> 取决于分配单元大小是否要取整

## 动态分配

### 动态分区分配

当程序被加载执行时，分配一个进程指定大小可变的分区（块，内存块）

分区的地址是连续的

### 操作系统需要维护的数据结构

所有进程的已分配分区

空闲分区（Empty-blocks）

### 动态分区分配策略

#### 最先匹配（First-fit）

##### 思路：找到的第一个满足指定大小的

> 分配n个字节，使用第一个可用空间比n大的空闲块

##### 原理&实现：

1. 空闲分区列表按照地址顺序排序
2. 分配过程中，搜索第一个合适的分区
3. 释放分区时，检查是否可与临近的空闲分区合并

##### 优点

简单，在高地址空间会留下大块的空闲分区

##### 缺点

会出现外部碎片，分配大块时较慢

#### 最佳匹配（Best-fit）

##### 思路：

遍历所有空闲分区后确定大于指定大小且差值最小的分区

> 分配n字节分区时，查找并使用不小于n的最小空闲分区

##### 原理&实现

1. 空闲分区列表按小到大排序
2. 分配时查找一个合适的分区
3. 释放时，查找并合并临近的空闲分区

##### 优点

大部分分配的尺寸较小时，效果好

可以避免大的空闲分区被拆分

可以减小外部碎片的大小

相对简单

##### 缺点

产生大量外部碎片

释放分区较慢

产生很多无法使用的小碎片



#### 最差匹配（Worst-fit）

##### 思路：

找到最大的空闲分区

>分配n字节，使用尺寸不小于n的最大空闲空间

##### 原理&实现

1. 空闲分区列表由大到小排序
2. 分配时，选最大的分区
3. 释放时，检查是否可与临近的空闲分区合并，进行可能的合并并调整空闲分区列表顺序

##### 优点

中等大小的分配较多时，效果好

避免了太多的小碎片

##### 缺点

释放分区较慢

外部碎片

容易破坏大的空闲分区，因此之后难以分配大的分区



## 碎片整理

指通过调整进程占用的分区位置，来减少或避免分区碎片

### 紧凑（compaction）

#### 目的

通过移动分配给进程的内存分区，以合并外部碎片

#### 条件

所有的应用程序可动态重定位

#### 需要解决的问题

什么时候移动

开销

### 分区对换（Swapping in/out）

通过抢占并回收处于等待状态进程的分区，以增大可用内存空间

> 将内存中处于等待状态的进程移到外存中，等待内存中的进程让出处理机使用权限

用于早期的内存紧张的情形下实现多进程的交替运行，而这种交替因为内外存的速度差异，开销非常大

同时需要解决交换哪个程序（权衡开销）

# 3.伙伴系统（Buddy System）

规定整个可分配的分区大小为2的幂

需要的分区大小为大于低次幂而小于高次幂时，分配整块空闲分区

## 需要维护的数据结构

空闲块按大小和起始地址组织成二位数组

初始状态只有一个2的幂大小的空闲块

## 分配过程

1. 由小到大在空闲块数组中找最小的可用空闲块
2. 如空闲块过大，对可用空闲块进行二等分，直到得到合适的可用空闲块



## 释放过程

1. 把释放的块放入空闲块数组
2. 合并满足条件的空闲块

## 合并条件

大小相同，地址相邻，起始地址小的块的地址必须是2的i+1次幂的倍数

