# 1.计算机体系结构和内存层次

## 计算机体系结构

### cpu

寄存器  高速缓存（保证大量读写和复用）

### 内存

最小访问单位是8bit 32位总线一次读写4字节 



### I/O设备



## 内存层次

访问层次：高速缓存不命中时访问内存，内存缺页时访问外存，速度逐级下降，最快时与cpu主频一致

## 操作系统的内存管理方式

内存以字节为单位访问

外存磁盘的访问有扇区编号，一个扇区是512字节最小单位

MMU（存储管理单元）将逻辑（虚拟）的地址空间转化为真实的物理地址空间

操作系统在内存中，进程在外存和内存中

### 抽象

逻辑地址空间

### 保护

独立地址空间

### 共享

访问相同内存

### 虚拟化

拥有更大的地址空间

### 操作系统中采用的内存管理方式

#### 重定向（relocation）利用段地址加偏移

#### 分段（segmentation）程序逻辑结构分为代码，数据，堆栈三个部分相对独立

#### 分页（paging）将内存分为更小的段称为页，页内连续

#### 虚拟存储（virtual memory）采用逻辑的地址空间，目前多数系统（Linux）采用按需页式虚拟存储

## 存储管理的实现高度依赖于硬件结构

# 2.地址空间和地址生成

## 地址空间的定义

### 物理地址空间

由硬件支持，起始地址0，直到MAXsys

### 逻辑地址空间

在cpu运行的进程看到的地址，起始地址0，直到MAXprog，这段区域包含在物理地址空间里

## 地址生成

### 逻辑地址的生成

![image](https://github.com/Reichitose/OS/blob/main/image_storage/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%9A%84%E7%94%9F%E6%88%90.png)

源代码的语句被编译为cpu可以理解的汇编码，对汇编码再进行一次汇编变为机器指令，进行链接把多个模块和函数库排列成线性的函数库和指令，进行程序加载（重定位）平移到内存空间中某个位置

###  地址生成的时机和限制

#### 编译时（例如：非智能手机）

假设起始地址已知，如果起始地址改变，必须重新编译

#### 加载时

如果编译时其实位置未知，编译器需生成可重定位的代码（relocatable code），加载时生成绝对地址

#### 执行时（使用虚拟存储的系统里，最优）

执行时才可以确定需要访问的位置，执行时代码可移动，需地址转换（映射）硬件支持

### 生成过程

#### CPU：

ALU：需要逻辑地址的内存内容

MMU：依据页表将逻辑地址转换成物理地址

CPU控制逻辑：给总线发送物理地址请求和控制信号

#### 内存：

识别总线上的内容，发送物理地址的内容给CPU，或者接收CPU的数据到物理地址上，对应读和写

#### 操作系统：

通过逻辑地址LA和物理地址PA的映射，转换的表可以由操作系统控制

## 地址检查

![image](https://github.com/Reichitose/OS/blob/main/image_storage/%E5%9C%B0%E5%9D%80%E6%A3%80%E6%9F%A5.png)



请求由段长度寄存器进行检查，如果要访问的偏移量大于最大段长度，则判定为非法，如果在范围之内，则加上段基址转换为物理地址进行访问

操作系统可以通过软件方法设置base和limit逻辑地址空间
